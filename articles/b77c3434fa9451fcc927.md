---
title: "å‹å®‰å…¨ã§é«˜é€Ÿãªé€£é–è¡Œåˆ—ç©ã®è¨ˆç®—"
emoji: "ğŸ‘·"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Haskell", "å‹ãƒ¬ãƒ™ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°", "ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°", "ç«¶ãƒ—ãƒ­"]
published: true
---

ã“ã®è¨˜äº‹ã¯ [Haskell Advent Calendar 2021](https://qiita.com/advent-calendar/2021/haskell) ã®22æ—¥ç›®ã®è¨˜äº‹ã§ã™ã€‚

----

æ¬¡ã®ã‚ˆã†ãªï¼“ã¤ã®è¡Œåˆ—ã®ç©ã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚

$$
ABC =
\begin{pmatrix}
a_{00} & a_{01} & a_{02} \\
a_{10} & a_{11} & a_{12} \\
a_{20} & a_{21} & a_{22} \\
a_{30} & a_{31} & a_{32} \\
\end{pmatrix}
\begin{pmatrix}
b_{00} & b_{01} \\
b_{10} & b_{11} \\
b_{20} & b_{21} \\
\end{pmatrix}
\begin{pmatrix}
c_{00} & c_{01} & c_{02} & c_{03} & c_{04} \\
c_{10} & c_{11} & c_{12} & c_{13} & c_{14} \\
\end{pmatrix}
$$

**è¡Œåˆ—ç©ã¯çµåˆå¾‹ãŒæˆã‚Šç«‹ã¤**ã®ã§$AB$ã‚’å…ˆã«æ›ã‘ç®—ã—ã¦ã‚‚$BC$ã‚’å…ˆã«æ›ã‘ç®—ã—ã¦ã‚‚**çµæœã¯ä¸€è‡´**ã—ã¾ã™ã€‚

$$
(AB)C = A(BC)
$$

ã—ã‹ã—**è¨ˆç®—ã«å¿…è¦ã¯æ¼”ç®—ã®å›æ•°**ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ã€‚ã¾ãš$AB$ã‚’å…ˆã«æ›ã‘ç®—ã—ãŸå ´åˆã€$4\times 3$è¡Œåˆ—ã¨$3\times 2$è¡Œåˆ—ã®ç©ã«ãªã‚‹ã®ã§$3$æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ã®å†…ç©ã‚’$4\times 2 = 8$å›ç¹°ã‚Šè¿”ã™ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ç‰¹ã«è¦ç´ ã®ç©ã«æ³¨ç›®ã™ã‚‹ã¨$3\times 4\times 2=24$å›ã®ç©ãŒè¡Œã‚ã‚Œã¾ã™ã€‚ä¸€èˆ¬ã«$p\times q$è¡Œåˆ—ã¨$q\times r$è¡Œåˆ—ã®è¡Œåˆ—ç©ã§ã¯$pqr$å›ã®è¦ç´ ã®ç©ã¨$p(q-1)r$å›ã®è¦ç´ ã®å’Œã‚’è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€æ¼”ç®—ã‚’å®Ÿè¡Œã™ã‚‹å›æ•°ã®ã‚ªãƒ¼ãƒ€ãƒ¼ã¯$O(pqr)$ã§ã‚ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚ãã®å¾Œ$4\times 2$è¡Œåˆ—$AB$ã¨$2\times 5$è¡Œåˆ—$C$ã®ç©ã‚’è¡Œã„ã€æ¼”ç®—ã¯$2\times 4\times 5= 40$å›è¡Œã‚ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã™ãªã‚ã¡è¡Œåˆ—ç©$(AB)C$ã«ãŠã‘ã‚‹æ¼”ç®—ã¯åˆè¨ˆ$24+40=64$å›è¡Œã‚ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

åå¯¾ã«$BC$ã‚’å…ˆã«æ›ã‘ç®—ã—ãŸå ´åˆã€åŒæ§˜ã®è€ƒãˆæ–¹ã«ã‚ˆã‚Š$A(BC)$ã®è¨ˆç®—ã«$2\times 3\times 5 + 3\times 4\times 5 = 90$å›ã®æ¼”ç®—ãŒå¿…è¦ã«ãªã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šè¡Œåˆ—ç©ã¯ã©ã“ã‹ã‚‰è¨ˆç®—ã—ã¦ã‚‚ç­”ãˆã¯åŒã˜ã«ãªã‚Šã¾ã™ãŒ**è¨ˆç®—ã«ã‹ã‹ã‚‹ã‚³ã‚¹ãƒˆã¯è¨ˆç®—ã™ã‚‹é †ç•ªã«ã‚ˆã£ã¦å¤‰ã‚ã£ã¦ãã‚‹**ã®ã§ã™ã€‚

è¨ˆç®—ã™ã‚‹é †ç•ªã¯ä¸ãˆã‚‰ã‚ŒãŸè¡Œåˆ—ç©ã«ã©ã®ã‚ˆã†ãªæ‹¬å¼§ã¤ã‘ã‚‹ã®ã‹ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚æ‹¬å¼§ã‚’ä»˜ã‘ã‚‹çµ„ã¿åˆã‚ã›ã®æ•°ã¯3ã¤ã®è¡Œåˆ—ã®ç©ã§ã¯2é€šã‚Šã—ã‹ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸãŒã€æ›ã‘åˆã‚ã›ã‚‹è¡Œåˆ—ã®æ•°ãŒå¢—ãˆã‚‹ã«ã¤ã‚Œã¦**æŒ‡æ•°é–¢æ•°çš„ã«å¢—åŠ **ã—ã¦ã„ãã¾ã™ã€‚ãªã®ã§å…¨ã¦ã®çµ„ã¿åˆã‚ã›ã‚’åˆ—æŒ™ã—ã¦è¡Œåˆ—ç©ã®ã‚³ã‚¹ãƒˆãŒä¸€ç•ªä½ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ç´¢ã™ã‚‹ã®ã¯å›°é›£ã§ã™ã€‚ã—ã‹ã—$n$ã‚’æ›ã‘åˆã‚ã›ã‚‹è¡Œåˆ—ã®å€‹æ•°ã¨ã—ãŸæ™‚ã€å®Ÿã¯æœ€é©ãªè¨ˆç®—é †åºã¯**å‹•çš„è¨ˆç”»æ³•ã‚’ä½¿ã†ã“ã¨ã§$O(n^2)$ã§æ±‚ã¾ã‚‹**ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™[^1]ã€‚ã“ã®ã‚ˆã†ã«è¤‡æ•°ã®è¡Œåˆ—ãŒä¸ãˆã‚‰ã‚ŒãŸæ™‚ã€ãã‚Œã‚‰ã®ç©ã‚’è¡Œã†æœ€å°ã‚³ã‚¹ãƒˆã‚’æ±‚ã‚ã‚‹å•é¡Œã¯**é€£é–è¡Œåˆ—ç©å•é¡Œ**ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚

ã¨ã“ã‚ã§Haskellã§ã¯**ãƒ™ã‚¯ãƒˆãƒ«ã‚„è¡Œåˆ—ã®å‹ã«ãã‚Œã‚‰ã®æ¬¡å…ƒã«é–¢ã™ã‚‹æƒ…å ±ã‚’æŒãŸã›ã‚‹**ãŒã§ãã¾ã™ã€‚ãã“ã§è¡Œåˆ—ç©ã‚’è¡Œã†è¡Œåˆ—ã®çµ„ã¿åˆã‚ã›ãŒä¸ãˆã‚‰ã‚ŒãŸæ™‚ã«ã€**å‹ã«ã‚ã‚‹æ¬¡å…ƒã®æƒ…å ±ã‹ã‚‰æœ€é©ãªè¡Œåˆ—ç©ã‚’è¡Œã†é †ç•ªã‚’è‡ªå‹•çš„ã«è¨ˆç®—ã—ãã®é€šã‚Šã«è¡Œåˆ—ç©ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ãªé–¢æ•°ã‚’å®Ÿè£…ã™ã‚‹**ã“ã¨ã¯ã§ããªã„ã§ã—ã‚‡ã†ã‹ã€‚

## è¡Œåˆ—ã¨é€£é–è¡Œåˆ—ã®å‹
ã“ã®è¨˜äº‹ã§ã¯ç·šå½¢ä»£æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã—ã¦hmatrixã®[Numeric.LinearAlgebra.Static](https://hackage.haskell.org/package/hmatrix-0.20.2/docs/Numeric-LinearAlgebra-Static.html)ã‚’ç”¨ã„ã¾ã™ã€‚ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§$m\times n$è¡Œåˆ—ã®å‹ã¯

```hs
data L m n = ...
```

ã¨å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

è¡Œåˆ—ç©ã‚’è¡Œã†å¯¾è±¡ã¨ãªã‚‹è¤‡æ•°ã®è¡Œåˆ—ã®çµ„ã€ã™ãªã‚ã¡é€£é–è¡Œåˆ—ã‚’è¡¨ã™å‹ã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚æœ€ã‚‚ç°¡å˜ã«æ€ã„ã¤ãã®ã¯è¡Œåˆ—ã®å˜ç´”ãªãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ã§ã—ã‚‡ã†ã€‚

```hs
type MCList m n = [L m n]
```

ã“ã“ã§`MCList`ã¯Matrix Chain Listã®æ„å‘³ã§ã™ã€‚ã—ã‹ã—ã“ã‚Œã¯ã†ã¾ãã„ãã¾ã›ã‚“ã€‚ãªãœãªã‚‰ã“ã®å‹ã§ã¯ãƒªã‚¹ãƒˆã®è¦ç´ ã¯å…¨ã¦$m\times n$è¡Œåˆ—ã¨ãªã£ã¦ã—ã¾ã„ã¾ã™ãŒã€å®Ÿéš›ã®è¡Œåˆ—ç©ã¯$m\times k$è¡Œåˆ—ã¨$k\times n$è¡Œåˆ—ã®ç©ãªã©æ§˜ã€…ãªå‹ã®è¡Œåˆ—ã®ç©ã‚’è€ƒãˆãªã‘ã‚Œã°ã„ã‘ãªã„ã‹ã‚‰ã§ã™ã€‚

ãã“ã§GADTã‚’ç”¨ã„ã¦ç‹¬è‡ªã®ãƒ‡ãƒ¼ã‚¿å‹ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†[^2]ã€‚

```hs
data MCList m n where
  S :: L m n -> MCList m n
  (:.) :: KnownNat k => L m k -> MCList k n -> MCList m n

infixr 5 :.
```

ã“ã®`MCList m n`ã¯**è¡Œåˆ—ç©ã‚’è¡Œãªã£ãŸçµæœãŒ$m\times n$è¡Œåˆ—ã¨ãªã‚‹ã‚ˆã†ãªé€£é–è¡Œåˆ—ã‚’è¡¨ã™å‹**ã§ã™ã€‚`S`ã¯è¡Œåˆ—ã‚’1ã¤å–ã£ã¦`MCList`ã‚’æ§‹ç¯‰ã™ã‚‹å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚ã‚Šã€`(:.)`ã¯è¨ˆç®—çµæœãŒ$k\times n$è¡Œåˆ—ã¨ãªã‚‹é€£é–è¡Œåˆ—ã®å‹ã®å…ˆé ­ã«$m\times k$è¡Œåˆ—ã‚’è¿½åŠ ã™ã‚‹å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã™ã€‚`(:.)`ã¯**ä¸­é–“ã«ã‚ã‚‹æ¬¡å…ƒ`k`ã‚’å­˜åœ¨å‹ã§éš è”½ã—ã¦ã—ã¾ã†**ã®ã§çµæœã®å‹`MCList m n`ã«`k`ãŒç¾ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¸­é–“ã«ã‚ã‚‹æ¬¡å…ƒã‚’æ˜ç¤ºçš„ã«ç®¡ç†ã—ãªã„ã“ã¨ã§ã‚³ãƒ¼ãƒ‰ãŒç…©é›‘ã«ãªã‚‹ã“ã¨ã‚’é˜²ã„ã§ã„ã¾ã™ã€‚ãŸã ã—å˜ãªã‚‹å­˜åœ¨å‹ã ã¨å¾Œã®å®Ÿè£…ã§æ‰±ã„ã«å›°ã£ã¦ã—ã¾ã†ã®ã§`KnownNat`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã¨ã„ã†åˆ¶ç´„ã ã‘ã¤ã‘ã¦ã„ã¾ã™ã€‚

ã“ã®`MCList`ã‚’ä½¿ã£ã¦å˜ç´”ã«å³ã‹ã‚‰é †ç•ªã«è¡Œåˆ—ç©ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
naiveMcm :: (KnownNat m, KnownNat n) => MCList m n -> L m n
naiveMcm (S a)    = a
naiveMcm (a :. b) = a <> naiveMcm b
```

`(<>)`ã¯hmatrixãŒæä¾›ã™ã‚‹è¡Œåˆ—ç©ã‚’è¡Œã†æ¼”ç®—å­ã§ã™ã€‚ã“ã®æ¼”ç®—å­ã¯

```hs
(<>) :: L m k -> L k n -> L m n
```

ã¨ã„ã†å‹ã‚’ã—ã¦ã„ã¦ã€æ›ã‘åˆã‚ã›ã‚‹è¡Œåˆ—ã®æ¬¡å…ƒãŒæ­£ã—ãæƒã£ã¦ã„ãªã„ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒã§ããªã„ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚`naiveMcm`ã®å®Ÿè£…ã§ã¯**GADTã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãŒè¡Œã‚ã‚Œã‚‹ã“ã¨ã§è¡Œåˆ—`a`ã®åˆ—ã®æ¬¡å…ƒã¨é€£é–è¡Œåˆ—`b`ã®è¡Œã®æ¬¡å…ƒãŒä¸€è‡´ã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã‚‹**ã®ã§ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã¯å•é¡Œãªãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã€‚

## å‹ã®æƒ…å ±ã‹ã‚‰é€£é–è¡Œåˆ—å•é¡Œã‚’è§£ã
é€£é–è¡Œåˆ—å•é¡Œã‚’è§£ããŸã‚ã«ã€ã¾ãšã¯**é€£é–è¡Œåˆ—ã®å‹ã‹ã‚‰è¡Œåˆ—ã®æ¬¡å…ƒã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦å–ã‚Šå‡ºã™**é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
num :: forall n a. (KnownNat n, Num a) => a
num = fromIntegral $ natVal (Proxy @n)

dims :: forall m n. (KnownNat m, KnownNat n) => MCList m n -> [Int]
dims (S a)      = [num @m, num @n]
dims (_ :. mcm) = num @m : dims mcm
```

`num`ã¯`TypeApplications`ã‚’åˆ©ç”¨ã—ã¦å‹ãƒ¬ãƒ™ãƒ«ã®è‡ªç„¶æ•°ã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã™ãŸã‚ã®è£œåŠ©é–¢æ•°ã§ã™ã€‚`dims`ã¯`MCList`ã‚’å†å¸°çš„ã«è¾¿ã£ã¦è¡Œåˆ—ã®æ¬¡å…ƒã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‹é–¢æ•°ã§ã™ã€‚ä¾‹ãˆã°$p\times q$è¡Œåˆ—ã¨$q\times r$è¡Œåˆ—ã¨ã„ã†2ã¤ã®è¡Œåˆ—ã®ç©ã‚’`dims`ã«ä¸ãˆã‚‹ã¨`[p, q, r]`ã¨ã„ã†ãƒªã‚¹ãƒˆãŒè¿”ã£ã¦ãã¾ã™ã€‚ã“ã®ãƒªã‚¹ãƒˆã®é•·ã•ã¯ä¸ãˆãŸé€£é–è¡Œåˆ—ã«å«ã¾ã‚Œã‚‹è¡Œåˆ—ã®æ•°ã‚ˆã‚Š1ã¤é•·ããªã£ã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

ã„ã‚ˆã„ã‚ˆå‹•çš„è¨ˆç”»æ³•ã‚’ä½¿ã£ã¦è¡Œåˆ—ç©ã®æœ€å°ã‚³ã‚¹ãƒˆã‚’æ±‚ã‚ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ãŸã ã—ã‚ˆãã‚ã‚‹ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å•é¡Œã¨ã¯é•ã£ã¦ä»Šå›ã¯æœ€çµ‚çš„ã«è¡Œåˆ—ç©è‡ªä½“ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒç›®çš„ã§ã™ã€‚ãªã®ã§**æœ€å°ã‚³ã‚¹ãƒˆã‚’æ±‚ã‚ã‚‹ã¨åŒæ™‚ã«ãã‚Œã‚’é”æˆã™ã‚‹è¨ˆç®—é †åºã‚‚æ±‚ã‚ã‚‹**å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚è¨ˆç®—é †åºã¯äºŒåˆ†æœ¨ã‚’ä½¿ã£ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ã“ã¨ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¤ãƒ¡ãƒ¼ã‚¸ã™ã‚‹ã¨è‰¯ã„ã§ã—ã‚‡ã†ã€‚

![](https://storage.googleapis.com/zenn-user-upload/be8f971a9497-20211221.png =600x)

è¨ˆç®—é †åºã‚’è¡¨ã™ãƒ‡ãƒ¼ã‚¿å‹ã¨ã—ã¦å½¢çŠ¶ã®æƒ…å ±ã®ã¿ã‚’æŒã¤äºŒåˆ†æœ¨ã®å‹ã‚’ç”¨æ„ã—ã¦ãŠãã¾ã™ã€‚

```hs
data Tree = Leaf | Node Tree Tree
          deriving (Eq, Ord)
```

å‹•çš„è¨ˆç”»æ³•ã‚’å®Ÿè£…ã™ã‚‹æ–¹é‡ã¯ã€iç•ªç›®ã®è¡Œåˆ—ã‹ã‚‰jç•ªç›®ã®è¡Œåˆ—ã¾ã§ã®ç©ã‚’æ±‚ã‚ã‚‹æœ€å°ã‚³ã‚¹ãƒˆã‚’ãƒœãƒˆãƒ ã‚¢ãƒƒãƒ—ã«è¨ˆç®—ã—ã¦ã„ãã¨ã„ã†ã‚‚ã®ã§ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/075c406170bb-20211221.png =600x)

iã‹ã‚‰jç•ªç›®ã®è¡Œåˆ—ç©ã‚’è€ƒãˆã‚‹æ™‚ã€é–“ã«ã‚ã‚‹kç•ªç›®ã§åŒºåˆ‡ã£ãŸå ´åˆã«ã‹ã‹ã‚‹è¨ˆç®—ã‚³ã‚¹ãƒˆã¯ã€

- iã‹ã‚‰kç•ªç›®ã¾ã§ã®è¡Œåˆ—ç©ã®æœ€å°ã‚³ã‚¹ãƒˆ
- k+1ã‹ã‚‰jç•ªç›®ã¾ã§ã®è¡Œåˆ—ç©ã®æœ€å°ã‚³ã‚¹ãƒˆ
- i,k+1,j+1ç•ªç›®ã®æ¬¡å…ƒã®ç©

ã“ã‚Œã‚‰ã®å’Œã«ãªã‚Šã¾ã™ã€‚æœ€å¾Œã§kã¨jã«1ãŒè¶³ã•ã‚Œã¦ã„ã‚‹ã®ã¯æ¬¡å…ƒã®ãƒªã‚¹ãƒˆãŒç©ã‚’è¡Œã†æ•°ã®ãƒªã‚¹ãƒˆã‚ˆã‚Š1ã¤é•·ããªã£ã¦ã„ã‚‹ã“ã¨ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/fe4791bd1af0-20211221.png =500x)

ã“ã‚Œã‚’kã‚’iã‹ã‚‰j-1ã¾ã§é †ç•ªã«å¤‰åŒ–ã•ã›ã¦è¨ˆç®—ã—ã€ãã®ä¸­ã§ä¸€ç•ªå°ã•ã„ã‚³ã‚¹ãƒˆãŒiã‹ã‚‰jç•ªç›®ã®è¡Œåˆ—ç©ã®æœ€å°ã‚³ã‚¹ãƒˆã«ãªã‚‹ã¨ã„ã†ã‚ã‘ã§ã™ã€‚

ã“ã®è¨ˆç®—ã‚’è¡Œãªã£ãŸå€¤ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«2æ¬¡å…ƒã®é…åˆ—ã‚’ç”¨æ„ã—ã¾ã™ã€‚è¨ˆç®—ã¯ç©ã‚’è¡Œã†è¡Œåˆ—ã®æ•°ãŒå°‘ãªã„æ–¹ã‹ã‚‰ã€ã¤ã¾ã‚Š2æ¬¡å…ƒé…åˆ—ã®å¯¾è§’ç·šã‹ã‚‰é †ç•ªã«è¡Œãªã£ã¦ã„ãã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/775b0e3e9a35-20211221.png =800x)

```hs
minCost :: (KnownNat m, KnownNat n) => MCList m n -> (Int, Tree)
minCost xs = runST $ do
  let ds = dims xs
      n = length ds - 1
      costs = listArray (0,n) ds :: UArray Int Int
      indices = [(x, x+offset) | offset <- [0..n-1], x <- [0..n-1-offset]]
  table <- newArray_ ((0,0), (n-1,n-1)) :: ST s (STArray s (Int, Int) (Int, Tree))
  for_ indices $ \(i,j) ->
    if i == j then writeArray table (i,j) (0, Leaf)
    else do
      candidates <- for [i..j-1] $ \k -> do
        (cik, tik) <- readArray table (i,k)
        (ckj, tkj) <- readArray table (k+1,j)
        pure (cik + ckj + costs!i * costs!(k+1) * costs!(j+1), Node tik tkj)
      writeArray table (i, j) $ minimum candidates
  readArray table (0, n-1)
```

ã“ã®`minCost`ã‚’ä½¿ãˆã°è¡Œåˆ—ç©ã®ã‚³ã‚¹ãƒˆãŒæœ€å°ã«ãªã‚‹è¨ˆç®—é †åºã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## è¨ˆç®—é †åºã«æ²¿ã£ã¦è¡Œåˆ—ç©ã‚’è¨ˆç®—ã™ã‚‹
é€£é–è¡Œåˆ—`MCList`ã¨ãã‚Œã‚’æœ€å°ã‚³ã‚¹ãƒˆã§è¨ˆç®—ã™ã‚‹è¨ˆç®—é †åº`Tree`ãŒæ‰‹ã«å…¥ã£ãŸã®ã§ã€å®Ÿéš›ã«è¨ˆç®—é †åºã«æ²¿ã£ã¦è¡Œåˆ—ç©ã‚’è¨ˆç®—ã™ã‚‹æ–¹æ³•ã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚ãã®ãŸã‚ã«ã¯å˜ãªã‚‹ãƒªã‚¹ãƒˆã§ã¯ãªã**è¨ˆç®—é †åºã‚‚åæ˜ ã—ãŸé€£é–è¡Œåˆ—ã®å‹**ã‚’è€ƒãˆãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“ã€‚ã“ã‚Œã‚’ä»¥ä¸‹ã®ã‚ˆã†ãªå‹ã‚’æŒã£ãŸæœ¨ã¨ã—ã¦å®Ÿè£…ã—ã¾ã™ã€‚

```hs
data MCTree m n where
  L :: L m n -> MCTree m n
  N :: KnownNat k => MCTree m k -> MCTree k n -> MCTree m n
```

`MCTree m n`ã¯è¨ˆç®—çµæœãŒ$m\times n$è¡Œåˆ—ã¨ãªã‚‹ã‚ˆã†ãªé€£é–è¡Œåˆ—ã‚’è¡¨ã™å‹ã§ã™ã€‚ã“ã®å‹ã‚’ç”¨ã„ãŸé€£é–è¡Œåˆ—ç©ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```hs
mcmTree :: (KnownNat m, KnownNat n) => MCTree m n -> L m n
mcmTree (L a) = a
mcmTree (N l r) = mcmTree l <> mcmTree r
```

**æœ¨æ§‹é€ ã‚’ç”¨ã„ã‚‹ã“ã¨ã§è¨ˆç®—é †åºãŒæœŸå¾…é€šã‚Šã«åæ˜ ã•ã‚Œã¦ã„ã‚‹**ã®ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

ãã‚Œã§ã¯æœ€ã‚‚é‡è¦ãª`MCTree`ã®ä½œã‚Šæ–¹ã«ã¤ã„ã¦è¦‹ã¦ã„ãã¾ã—ã‚‡ã†ã€‚ã„ããªã‚Šè¤‡é›‘ãªå‹ã§è€ƒãˆã‚‹ã®ã¯é›£ã—ã„ã®ã§ã€ã¾ãšã¯æ™®é€šã®ãƒªã‚¹ãƒˆã‚’æ™®é€šã®æœ¨ã«æ²¿ã£ã¦æœ¨ã‚’çµ„ã¿ç«‹ã¦ã‚‹é–¢æ•°ã‚’è€ƒãˆã¦ã¿ã¾ã™ã€‚

```hs
data Tree' a = Leaf' a
             | Node' (Tree' a) (Tree' a)

buildLT :: [a] -> Tree' () -> (Tree' a, [a])
buildLT (a:as) (Leaf' _) = (Leaf' a, as)
buildLT as (Node' l r) =
  let (l', as')  = buildLT as  l
      (r', rest) = buildLT as' r
   in (Node' l' r', rest)
```

`buildLT`ã¯ãƒªã‚¹ãƒˆ`[a]`ã®è¦ç´ ã‚’æ§‹é€ `Tree' ()`ã«æ²¿ã£ã¦çµ„ã¿ç«‹ã¦ãŸæœ¨`Tree' a`ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã§ã™ã€‚è¿”ã‚Šå€¤ãŒçµ„ã¿ç«‹ã¦ãŸæœ¨`Tree' a`ã¨ä½™ã£ãŸè¦ç´ ã®ãƒªã‚¹ãƒˆ`[a]`ã®ã‚¿ãƒ—ãƒ«ã«ãªã£ã¦ã„ã‚‹ã®ã§å†å¸°çš„ã«æœ¨ã‚’çµ„ã¿ç«‹ã¦ã¦ã„ãã“ã¨ãŒã§ãã¾ã™ã€‚`buildLT`ã®å®Ÿè£…ã§`Node'`ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã•ã‚ŒãŸéƒ¨åˆ†ã‚’è¦‹ã¦ã¿ã‚‹ã¨ã€ã¾ãš`Node'`ã®å·¦å´ã®æœ¨`l`ã¨ä¸ãˆã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆå…¨ä½“`as`ã§æœ¨ã®çµ„ã¿ç«‹ã¦ã‚’è¡Œã„ã€ä½™ã£ãŸè¦ç´ ã®ãƒªã‚¹ãƒˆ`as'`ã‚’ä½¿ã£ã¦å³å´ã®æœ¨`r`ã§æœ¨ã®çµ„ã¿ç«‹ã¦ã‚’è¡Œã£ã¦ã„ã‚‹ã¨ã„ã†å‡¦ç†ã®æµã‚Œã§ã™ã€‚

åŒæ§˜ã®å‡¦ç†ã‚’`MCList`ã¨`MCTree`ã§è¡ŒãŠã†ã¨ã™ã‚‹ã¨1ã¤å›°ã£ãŸã“ã¨ãŒèµ·ã“ã‚Šã¾ã™ã€‚æœ¨ã‚’çµ„ã¿ç«‹ã¦ã‚‹é€”ä¸­ã§é€£é–è¡Œåˆ—ã‚’çµ„ã¿ç«‹ãŸæœ¨ã¨ä½™ã‚Šã®è¦ç´ ã®ãƒªã‚¹ãƒˆã«åˆ†è½„ã™ã‚‹ã®ã§ã™ãŒã€ã“ã®åˆ†å‰²ã‚’è¡Œã£ãŸéš›ã«**å¢ƒç•Œã«ã‚ã‚‹æ¬¡å…ƒãŒæœ¨ã¨ãƒªã‚¹ãƒˆã§ä¸€è‡´ã—ã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹å¿…è¦ãŒå‡ºã¦ãã‚‹**ã®ã§ã™ã€‚ã“ã‚Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ‡ãƒ¼ã‚¿å‹ã‚’æ–°ãŸã«å®šç¾©ã—ã¾ã™ã€‚

```hs
data SomeTreeList m n where
  NoRest :: MCTree m n -> SomeTreeList m n
  SomeTreeList :: KnownNat k => (MCTree m k, MCList k n) -> SomeTreeList m n
```

`NoRest`ã¯ä½™ã‚Šã®è¦ç´ ã®ãƒªã‚¹ãƒˆãŒç©ºã«ãªã£ãŸå ´åˆã‚’è¡¨ã—ã¾ã™ã€‚`SomeTreeList`ã¯æœ¨ã¨ãƒªã‚¹ãƒˆã®ãƒšã‚¢ã«ãªã£ã¦ã„ã¾ã™ãŒå­˜åœ¨å‹ã«ã‚ˆã£ã¦**é–“ã®æ¬¡å…ƒ`k`ãŒä¸€è‡´ã—ã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹**ã‚ˆã†ã«ã§ãã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚Œã°`MCList`ã¨`Tree`ã‹ã‚‰æœ¨ã‚’çµ„ã¿ç«‹ã¦ã‚‹é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```hs
buildMCTree :: (KnownNat m, KnownNat n) => MCList m n -> Tree -> SomeTreeList m n
buildMCTree (S a)    Leaf = NoRest (L a)
buildMCTree (a :. b) Leaf = SomeTreeList (L a, b)
buildMCTree as (Node l r) =
  case buildMCTree as l of
    (NoRest _) -> undefined
    (SomeTreeList (l', as')) ->
      case buildMCTree as' r of
        (NoRest r') -> NoRest (N l' r')
        (SomeTreeList (r', rest)) -> (SomeTreeList (N l' r', rest))
```

å‹•ä½œã¯`buildLT`ã®å ´åˆã¨ã»ã¼åŒã˜ã§ã™ã€‚çµ„ã¿ç«‹ãŸæœ¨ã‚’ä½¿ã£ã¦è¡Œåˆ—ç©ã‚’è¡Œã†é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
mcm :: (KnownNat m, KnownNat n) => MCList m n -> L m n
mcm xs =
  let (_, parenthesis) = minCost xs
   in case buildMCTree xs parenthesis of
        (NoRest tree) -> mcmTree tree
        (SomeTreeList (tree, _)) -> undefined
```

`buildMCTree`ã¨`mcm`ã«`undefined`ãŒç¾ã‚Œã‚‹ç®‡æ‰€ãŒ1ã¤ãšã¤ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ä¸ãˆã‚‰ã‚ŒãŸ`MCList`ã¨`Tree`ã®é•·ã•ãŒä¸€è‡´ã—ã¦ã„ã‚‹ä¿è¨¼ãŒå‹ãƒ¬ãƒ™ãƒ«ã§ä¸ãˆã‚‰ã‚Œã¦ã„ãªã„ãŸã‚ã§ã€ãã‚Œãã‚Œæœ¨ãŒçŸ­ã‹ã£ãŸå ´åˆã¨é•·ã™ããŸå ´åˆã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ã•ã‚‰ã«å‹ãƒ¬ãƒ™ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’é€²ã‚ã‚‹ã“ã¨ã§ã“ã®`undefined`ã‚’ç„¡ãã›ã‚‹å¯èƒ½æ€§ã¯ã‚ã‚Šã¾ã™ãŒã€ä»Šå›ã¯è¨ˆç®—é †åºã®æœ¨ã®æ§‹ç¯‰ã¯`mcm`ã®ä¸­ã§å®Œçµã—ã¦ãŠã‚Šã€æœ¨ã¨ãƒªã‚¹ãƒˆã®é•·ã•ã¯å¿…ãšä¸€è‡´ã™ã‚‹ã®ã§æ·±ãã¯è¿½æ±‚ã—ãªã„ã“ã¨ã«ã—ã¾ã™ã€‚

æœ€å¾Œã«ã€å®Ÿè£…ã—ãŸ`mcm`ã‚’ä½¿ã†ã“ã¨ã§å®Ÿéš›ã«è¡Œåˆ—ç©ã®è¨ˆç®—ãŒé€Ÿããªã‚‹ã®ã‹ç¢ºèªã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
withTime :: IO a -> IO ()
withTime action = do
  start <- getCurrentTime
  action
  end <- getCurrentTime
  putStrLn $ formatTime defaultTimeLocale "Time: %-3Ess" (diffUTCTime end start)

main :: IO ()
main = do
  putStrLn "Generating random matrices"
  !a <- randn @100 @500
  !b <- randn @500 @1000
  !c <- randn @1000 @5000
  !d <- randn @5000 @10000
  let m = a :. b :. c :. S d

  putStrLn "# mcm"
  withTime . putStrLn $ "norm: " ++ show (norm_2 (mcm m))

  putStrLn "# naiveMcm"
  withTime . putStrLn $ "norm: " ++ show (norm_2 (naiveMcm m))
```

ã“ã®ä¾‹ã§ã¯$100\times 500$è¡Œåˆ—ã¨$500\times 1000$è¡Œåˆ—ã¨$1000\times 5000$è¡Œåˆ—ã¨$5000\times 10000$è¡Œåˆ—ã¨ã„ã†4ã¤ã®è¡Œåˆ—ã®ç©ã‚’è¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚`naiveMcm`ã«ã‚ˆã‚Šå³ã‹ã‚‰è¨ˆç®—ã™ã‚‹ã¨è¨ˆç®—ã‚³ã‚¹ãƒˆã¯

$$
100 \times 500 \times 10000 + 500 \times 1000 \times 10000 + 1000 \times 5000 \times 10000 = 555 \times 10^8
$$

ã¨ãªã‚Šã¾ã™ãŒã€`mcm`ã‚’ç”¨ã„ã¦å·¦ã‹ã‚‰è¨ˆç®—ã™ã‚‹ã“ã¨ã§

$$
100 \times 500 \times 1000 + 100 \times 1000 \times 5000 + 100 \times 5000 \times 10000 = 555 \times 10^7
$$

ã¨ãªã‚Šè¨ˆç®—ã‚³ã‚¹ãƒˆã‚’ã¡ã‚‡ã†ã©10åˆ†ã®1ã«æ¸›ã‚‰ã™ã“ã¨ãŒã§ãã¾ã™ã€‚å®Ÿè¡Œã—ã¦ã¿ã‚‹ã¨ã€

```md
Generating random matrices
# mcm
norm: 8072309.181602492
Time: 0.474s
# naiveMcm
norm: 8072309.181602493
Time: 3.209s
```

ã¨ãªã‚Šã€ã‚‚ã¡ã‚ã‚“é †åºè¨ˆç®—ãªã©ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãŒã‚ã‚‹ãŸã‚10åˆ†ã®1ã«ã¯ãªã‚Šã¾ã›ã‚“ãŒã€ã‹ãªã‚Šé«˜é€Ÿã«è¨ˆç®—ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸğŸ‘

ä»Šå›å®Ÿè£…ã—ãŸã‚³ãƒ¼ãƒ‰ã¯[ã“ã¡ã‚‰ã®gist](https://gist.github.com/lotz84/42fb385171a8f6d559bed052e5710263)ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ã¾ã™ã€‚

----

ï¼¼èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼ï¼
ã“ã®è¨˜äº‹ãŒé¢ç™½ã‹ã£ãŸã‚‰ ã„ã„ã­â™¡ ã‚’ã„ãŸã ã‘ã‚‹ã¨å¬‰ã—ã„ã§ã™â˜ºï¸
ãƒãƒƒã‚¸ã‚’è´ˆã£ã¦ã„ãŸã ã‘ã‚Œã°æ¬¡ã®è¨˜äº‹ã‚’æ›¸ããŸã‚åŠ±ã¿ã«ãªã‚Šã¾ã™ğŸ™Œ

[^1]: ã“ã®å•é¡Œã¯æ›´ã«åŠ¹ç‡çš„ã«è§£ãã“ã¨ãŒã§ã$O(n\log n)$ã§è§£ã‘ã‚‹ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ https://en.wikipedia.org/wiki/Matrix_chain_multiplication#More_efficient_algorithms
[^2]: ä»Šå›ã¯GADTã‚’ä½¿ã„ã¾ã—ãŸãŒãƒ˜ãƒ†ãƒ­ãƒªã‚¹ãƒˆã¨[singletons](https://hackage.haskell.org/package/singletons)ã‚’ä½¿ã£ãŸå®Ÿè£…ã‚‚å¯èƒ½ã§ã™ï¼ˆå°‘ã€…ç…©é›‘ã«ã¯ãªã‚Šã¾ã™ãŒï¼‰