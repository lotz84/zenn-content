---
title: "ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ï¼ãƒ‘ãƒ¼ã‚µãƒ¼ï¼‹ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹"
emoji: "ğŸ“"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Haskell"]
published: true
---

ã“ã®è¨˜äº‹ã¯[Haskell Advent Calendar 2022](https://qiita.com/advent-calendar/2022/haskell)ã®12æ—¥ç›®ã®è¨˜äº‹ã§ã™ã€‚

---

å…ˆæ—¥ï¼ˆ12/5~10ï¼‰é–‹å‚¬ã•ã‚ŒãŸ [OOPSLA 2022](https://2022.splashcon.org/track/splash-2022-oopsla?) ã§ ["Parsing Randomness"](https://2022.splashcon.org/details/splash-2022-oopsla/28/Parsing-Randomness) ã¨ã„ã†é¢ç™½ã„ç ”ç©¶ãŒç™ºè¡¨ã•ã‚Œã¦ã„ãŸã®ã§ç°¡å˜ã«ç´¹ä»‹ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚

è«–æ–‡ãŒå–ã‚Šæ‰±ã£ã¦ã„ã‚‹ä¸­å¿ƒçš„ãªãƒ†ãƒ¼ãƒã¯

> "A generator is a parser of randomness"

ã¨ã„ã†æ¨™èªã§è¡¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ã„ã†ã®ã¯ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ã‚’ç”Ÿæˆã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã“ã¨ã§ã€ä¾‹ãˆã°

```hs
data Tree a = Leaf | Node (Tree a) a (Tree a)
```

ã¨ã„ã†ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚Œã°

```hs
Node Leaf 5 Leaf
```

ã‚„

```hs
Node Leaf 5 (Node Leaf 8 Leaf)
```

ã¨ã„ã£ãŸå€¤ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ç”Ÿæˆã—ã¦ãã‚Œã‚‹ã¨ã„ã£ãŸã‚‚ã®ã§ã™ã€‚ã“ã†ã„ã£ãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒä½¿ã‚ã‚Œã‚‹ä¾‹ã¨ã—ã¦ã¯QuickCheckã®ã‚ˆã†ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆãŒæœ‰åã§ã—ã‚‡ã†ã€‚

æ¨™èªãŒä¸»å¼µã—ã¦ã„ã‚‹ã®ã¯ã“ã†ã„ã£ãŸ**ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã®ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆæ§‹æ–‡è§£æå™¨ï¼‰ã§ã‚ã‚‹**ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯å¿…è¦ã«å¿œã˜ã¦ä¹±æ•°ã‚’ä½¿ã„ãªãŒã‚‰ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’çµ„ã¿ç«‹ã¦ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã ã¨è€ƒãˆã‚‹ã¨ã€äºˆã‚ååˆ†ãªé•·ã•ã®ä¹±æ•°åˆ—ã‚’ç”Ÿæˆã—ã¦ãŠã‘ã°ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¯ãã‚Œã‚’å…ˆé ­ã‹ã‚‰æ¶ˆè²»ã—ãªãŒã‚‰ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’çµ„ã¿ç«‹ã¦ã‚‹ãƒ‘ãƒ¼ã‚µãƒ¼ã¨ã¿ãªã™ã“ã¨ãŒã§ãã€ã“ã®ä¸»å¼µã¯è‡ªç„¶ã«æ„Ÿã˜ã‚‰ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

è«–æ–‡ã§ã¯ Free Monad ã«ã‚ˆã£ã¦ä½œã‚‰ã‚ŒãŸ1ã¤ã®æŠ½è±¡çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰

- ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿
- ãƒ‘ãƒ¼ã‚µãƒ¼
- ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹

ãã‚Œãã‚Œã¸ã®å¤‰æ›ã‚’è€ƒãˆã€ **ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒãƒ‘ãƒ¼ã‚µãƒ¼ã¨ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã®çµ„ã¿åˆã‚ã›ã§è¡¨ã›ã‚‹** ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€æ¨™èªã®ä¸»å¼µã‚’è¨¼æ˜ã™ã‚‹ã¨ã„ã†ã“ã¨ãŒè¡Œã‚ã‚Œã¦ã„ã¾ã™ã€‚

ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ãƒ‘ãƒ¼ã‚µãƒ¼ãŒå¯¾å¿œã™ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚‹ã¨ä½•ãŒå¬‰ã—ã„ã‹ã¨ã„ã†ã¨ã€**ç‰‡æ–¹ã®ä¸–ç•Œã®çŸ¥è­˜ã‚’ã‚‚ã†ç‰‡æ–¹ã®ä¸–ç•Œã«æŒã£ã¦ã„ã**ã“ã¨ãŒå‡ºæ¥ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ãƒ‘ãƒ¼ã‚µãƒ¼ã®ä¸–ç•Œã§ã¯ã€Œæ­£è¦è¨€èªã®å¾®åˆ†ã€ï¼ˆBrzozowskiå¾®åˆ†ï¼‰ã¨ã„ã†æ¦‚å¿µã‚’è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ã“ã‚Œã‚’ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®ä¸–ç•Œã«æŒã£ã¦ãã‚‹ã¨ã©ã†ãªã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿå®Ÿã¯ã“ã®ãƒ‘ãƒ¼ã‚µãƒ¼ã®å¾®åˆ†ã«å¯¾å¿œã™ã‚‹æ¦‚å¿µã‚’ä½¿ã£ã¦"ä¸ãˆã‚‰ã‚ŒãŸæ¡ä»¶ã‚’æº€ãŸã™å€¤ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ "ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ã‚ˆã†ãªæ–¹æ³•ã§å¾—ã‚‰ã‚Œã‚‹ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ‰‹æ³•ã¯æ–°ã—ãã€è«–æ–‡ã§ã¯ **é¸æŠå‹¾é…ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆChoice Gradient Sampling (CGS)ï¼‰** ã¨åä»˜ã‘ã‚‰ã‚Œè©³ã—ãèª¿ã¹ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã®è¨˜äº‹ã§ã¯è«–æ–‡ã‚’å‚è€ƒã«ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒãƒ‘ãƒ¼ã‚µãƒ¼ã¨ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã®çµ„ã¿åˆã‚ã›ã§æ›¸ã‘ã‚‹ã“ã¨ã‚’å†ç¾ã—ã¦ã¿ãŸã„ã¨æ€ã„ã¾ã™ã€‚

## æ•°å¼ã‚’è¡¨ç¾ã™ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
æœ€åˆã«ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚„ãƒ‘ãƒ¼ã‚µãƒ¼ã®å¯¾è±¡ã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’è€ƒãˆãŸã„ã¨æ€ã„ã¾ã™ã€‚è«–æ–‡ä¸­ã§ã¯äºŒåˆ†æœ¨ã¨ãƒ©ãƒ ãƒ€è¨ˆç®—ãŒä¾‹ã¨ã—ã¦ä½¿ã‚ã‚Œã¦ã„ã¾ã™ãŒã€åŒã˜ä¾‹ã‚’æ‰±ã£ã¦ã‚‚ã¤ã¾ã‚‰ãªã„ã®ã§ã“ã“ã§ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå‹ã§è¡¨ã•ã‚Œã‚‹ **å››å‰‡æ¼”ç®—ã‚’ä½¿ã£ãŸè¨ˆç®—å¼** ã‚’ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã—ã¦è€ƒãˆãŸã„ã¨æ€ã„ã¾ã™ã€‚

```hs
data Expr = C Int
          | Add Expr Expr
          | Sub Expr Expr
          | Mul Expr Expr
          | Div Expr Expr
          deriving (Show)
```

ç°¡å˜ã®ãŸã‚ä»Šå›ã®è¨ˆç®—å¼ã«ç¾ã‚Œã‚‹æ•°å­—ã¯å…¨ã¦1æ¡ã¨ä»®å®šã—ã¾ã™ã€‚ã¤ã¾ã‚Š `C` ã«ä¸ãˆã‚‹å€™è£œã¨ãªã‚‹æ•°å­—ã¯0~9ã®10é€šã‚Šã§ã™ã€‚ã“ã®åˆ¶é™ã¯ã‚ãã¾ã§å®Ÿè£…ã‚’ç°¡å˜ã«ã™ã‚‹ãŸã‚ãªã®ã§ç†è«–çš„ãªåˆ¶ç´„ã«ã‚ˆã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ã“ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½¿ã£ã¦ã€ä¾‹ãˆã°

```
(1 + 2) Ã— 3
```

ã¨ã„ã†æ•°å¼ã¯

```hs
Mul (Add (Digit 1) (Digit 2)) (Digit 3)
```

ã®ã‚ˆã†ã«è¡¨ç¾ã—ã¾ã™ã€‚

æ‰‹å§‹ã‚ã«ã“ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
genExpr :: Int -> IO Expr
genExpr 0 = C <$> (frequency $ zip (repeat 1) [0 .. 9])
genExpr h = do
  c <- frequency [(1, '+'), (1, '-'), (1, '*'), (1, '/'), (1, 'c')]
  case c of
    '+' -> Add <$> genExpr (h-1) <*> genExpr (h-1)
    '-' -> Sub <$> genExpr (h-1) <*> genExpr (h-1)
    '*' -> Mul <$> genExpr (h-1) <*> genExpr (h-1)
    '/' -> Div <$> genExpr (h-1) <*> genExpr (h-1)
    'c' -> C <$> (frequency $ zip (repeat 1) [0 .. 9])
```

å˜ç´”ã«å®Ÿè£…ã™ã‚‹ã¨ã¨ã¦ã‚‚å·¨å¤§ãªå€¤ã‚’ç”Ÿæˆã—ã¦ã—ã¾ã†å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€æ•°å¼ã®ãƒã‚¹ãƒˆã®æ·±ã•ã‚’ `h` ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚`frequency` ã¯ä¸ãˆã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆã®è¦ç´ ã‚’é‡ã¿ã«å¿œã˜ã¦ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã™ã‚‹é–¢æ•°ã§ [System.Random](https://hackage.haskell.org/package/random-1.2.1.1/docs/System-Random.html) ã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

```hs
frequency :: [(Int, a)] -> IO a
frequency xs = do
  let total = sum (map fst xs)
      ys = snd $ foldr (\(n, a) (accum, ys) -> (accum+n, (accum+n, a):ys)) (0, []) xs
  n <- randomRIO (1, total)
  pure . snd . last $ takeWhile (\(i, _) -> i >= n) ys
```

å®Ÿéš›ã« `genExpr` ã‚’å®Ÿè¡Œã™ã‚‹ã¨æœŸå¾…é€šã‚Šãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

```hs
> genExpr 3
Mul (Add (Div (C 1) (C 7)) (Div (C 9) (C 3))) (Add (Div (C 9) (C 0)) (Div (C 3) (C 3)))
```

ä»Šåº¦ã¯ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã“ã“ã§ã¯[ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•](https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%BC%E3%83%A9%E3%83%B3%E3%83%89%E8%A8%98%E6%B3%95)ã§è¨˜è¿°ã•ã‚ŒãŸæ•°å¼ã‚’æ§‹æ–‡è§£æã—ã¦ `Expr` ã‚’çµ„ã¿ç«‹ã¦ã‚‹ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’è€ƒãˆã¾ã™ã€‚ãŸã ã—ãƒ‘ãƒ¼ã‚µãƒ¼ã®å®Ÿè£…ã‚’ç°¡å˜ã«ã™ã‚‹ãŸã‚ã€é€šå¸¸ã®ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•ã¨ç•°ãªã‚Šã€æ•°å­—ã®å‰ã«ã¯å¿…ãš `c` ã‚’ã¤ã‘ã‚‹ã¨ã„ã†ç´„æŸã«ã—ã¾ã™ã€‚

ã“ã®ã‚ˆã†ãªè¨˜æ³•ã«å¾“ã†ã¨ã€ä¾‹ãˆã°

```
(1 + 2) Ã— 3
```

ã¨ã„ã†æ•°å¼ã¯

```
*+c1c2c3
```

ã¨ã„ã†æ–‡å­—åˆ—ã§è¡¨ã•ã‚Œã¾ã™ã€‚

ã“ã®ãƒ‘ãƒ¼ã‚µãƒ¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```hs
parseExpr :: Int -> ReadP Expr
parseExpr 0 = get >> C . read . pure <$> get
parseExpr h = do
  c <- get
  case c of
    '+' -> Add <$> parseExpr (h-1) <*> parseExpr (h-1)
    '-' -> Sub <$> parseExpr (h-1) <*> parseExpr (h-1)
    '*' -> Mul <$> parseExpr (h-1) <*> parseExpr (h-1)
    '/' -> Div <$> parseExpr (h-1) <*> parseExpr (h-1)
    'c' -> C . read . pure <$> get
```

`ReadP` ã¯ [Text.ParserCombinators.ReadP](https://hackage.haskell.org/package/base-4.17.0.0/docs/Text-ParserCombinators-ReadP.html) ã¨ã—ã¦ base ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¼ã‚µãƒ¼ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ã®å‹ã§ã™ã€‚

è©¦ã—ã« `parseExpr` ã‚’ä½¿ã£ã¦æ–‡å­—åˆ—ã®æ§‹æ–‡è§£æã‚’è¡Œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
> readP_to_S (toP (fgenExpr 3)) "*+c1c4c3"
[(Mul (Add (C 1) (C 4)) (C 3),"")]
```

æœŸå¾…é€šã‚Šã®æŒ™å‹•ã«ãªã£ã¦ã„ã¾ã™ã­ã€‚`readP_to_S` ã¯

```hs
readP_to_S :: ReadP a -> String -> [(a, String)]
```

ã¨ã„ã†å‹ã®é–¢æ•°ã§ `ReadP a` ã‚’å®Ÿéš›ã«å®Ÿè¡Œã§ãã‚‹é–¢æ•°ã®å‹ `String -> [(a, String)]` ã«å¤‰æ›ã™ã‚‹å½¹å‰²ã‚’æœãŸã—ã¦ã„ã¾ã™ã€‚

ãƒ‘ãƒ¼ã‚µãƒ¼ `parseExpr` ã®å®Ÿè£…ã‚’ã‚ˆãè¦‹ã‚‹ã¨ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ `genExpr` ã®å®Ÿè£…ã«æ§‹é€ ãŒã‹ãªã‚Šä¼¼ã¦ã„ã‚‹äº‹ãŒåˆ†ã‹ã‚‹ã¨æ€ã„ã¾ã™ã€‚

## FGen a

ãã‚Œã§ã¯ã“ã‚Œã‚‰ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’çµ±ä¸€ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ Free Monad ã‚’ä½¿ã£ã¦å®Ÿè£…ã—ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

å®Ÿè£…ã‚’ç°¡å˜ã«ã™ã‚‹ãŸã‚ Freer Monad ã‚’ä½¿ã£ã¦å®Ÿè£…ã—ã¾ã™ã€‚

```hs
data Freer f a where
  Pure :: a -> Freer f a
  Bind :: f a -> (a -> Freer f b) -> Freer f b
```

`Freer f` ã¯`f`ã«ä½•ã®åˆ¶ç´„ã‚’ã¤ã‘ã‚‹ã“ã¨ç„¡ã Functor, Applicative, Monad ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```hs
instance Functor (Freer f) where
  fmap f (Pure a)    = Pure (f a)
  fmap f (Bind fa k) = Bind fa (fmap f . k)

instance Applicative (Freer f) where
  pure a = Pure a
  (Pure f)    <*> fa = fmap f fa
  (Bind ff k) <*> fa = Bind ff (\f -> k f <*> fa)

instance Monad (Freer f) where
  (Pure a)    >>= k = k a
  (Bind fa k) >>= l = Bind fa ((>>= l) . k)
```

ãªãœã“ã®ã‚ˆã†ãªã“ã¨ãŒå¯èƒ½ãªã®ã‹ã¨ã„ã†ã¨è£ã«ã¯é›¢æ•£åœã‹ã‚‰ã®å·¦Kanæ‹¡å¼µãŒã‚ã‚‹ã®ã§ã™ãŒã€Freer Monadã®è©³ã—ã„è©±ã‚’ã™ã‚‹ã¨é•·ããªã£ã¦ã—ã¾ã†ã®ã§æ°—ã«ãªã‚‹äººã¯ä»–ã®æ–‡çŒ®ã‚’å‚ç…§ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

- [Freer EffectsãŒã€ã ã„ãŸã„ã‚ã‹ã£ãŸ: 8. Freerãƒ¢ãƒŠãƒ‰(Operationalãƒ¢ãƒŠãƒ‰)ã§ã€ã„ã‚ã„ã‚ãªãƒ¢ãƒŠãƒ‰ã‚’æ§‹æˆã™ã‚‹ - Qiita](https://qiita.com/YoshikuniJujo/items/686fedc92fd20ff70ab8)
- [Kiselyov, Oleg, and Hiromi Ishii. "Freer monads, more extensible effects." ACM SIGPLAN Notices 50.12 (2015): 94-105.](https://okmij.org/ftp/Haskell/extensible/more.pdf)

ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚„ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’æŠ½è±¡åŒ–ã—çµ±ä¸€ã™ã‚‹æ¦‚å¿µã¯ **Free Generator** ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚Free Generator ã‚’è¡¨ã™å‹ `FGen a` ã‚’ä»¥ä¸‹ã®æ§˜ã«å®Ÿè£…ã—ã¾ã™ã€‚

```hs
type Weight = Int

type Choice = Char

data Pick a = Pick [(Weight, Choice, FGen a)]

type FGen a = Freer Pick a
```

`Weight` ã¯ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã®æ™‚ã«è€ƒæ…®ã™ã‚‹é‡ã¿ã€`Choice`ã¯ãƒ‘ãƒ¼ã‚¹ã™ã‚‹å¯¾è±¡ã‚„ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã®å‡ºåŠ›å¯¾è±¡ã¨ãªã‚‹è¨˜å·åˆ—ã®è¨˜å·ã€`Pick`ã¯`Choice`ã®ç¨®é¡ã«åˆã‚ã›ãŸåˆ†å²ã«ãŠã‘ã‚‹é¸æŠè‚¢ã€ã“ã®`Pick`ã‚’ Freer Monad ã«ã—ãŸã‚‚ã®ãŒ `FGen a` ã¨ãªã‚Šã¾ã™ã€‚å®Ÿã¯ `Pick` ã®å®Ÿè£…æ–¹æ³•ã‹ã‚‰ã‚‚ã‚ã‹ã‚‹é€šã‚Šä»Šå›ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯æœ‰é™å€‹ã®è¨˜å·ï¼é¸æŠè‚¢ã‹ã‚‰ãªã‚‹å¯¾è±¡ã«ã—ã‹ä½¿ã†ã“ã¨ãŒå‡ºæ¥ãªã„ã¨ã„ã†æš—é»™ã®åˆ¶ç´„ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã® `FGen a` ã‚’ä½¿ã£ã¦ `Expr` ã® Free Generator ã§ã‚ã‚‹ `FGen Expr` ã‚’å®Ÿè£…ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```hs
fgenExpr :: Int -> FGen Expr
fgenExpr 0 = Bind
  (Pick [(1, 'c', Pure 'c')])
  (\_ -> Bind (Pick $ map (\c -> (1, c, Pure $ C (read [c]))) ['0'..'9']) Pure)
fgenExpr h = Bind
  (Pick [(1, '+', Pure '+'), (1, '-', Pure '-'), (1, '*', Pure '*'), (1, '+', Pure '+'), (1, 'c', Pure 'c')])
  (\c -> case c of
    '+' -> Add <$> fgenExpr (h-1) <*> fgenExpr (h-1)
    '-' -> Sub <$> fgenExpr (h-1) <*> fgenExpr (h-1)
    '*' -> Mul <$> fgenExpr (h-1) <*> fgenExpr (h-1)
    '/' -> Div <$> fgenExpr (h-1) <*> fgenExpr (h-1)
    'c' -> Bind (Pick $ map (\c -> (1, c, Pure $ C (read [c]))) ['0'..'9']) Pure)
```

## `FGen a` ã‹ã‚‰ã®å¤‰æ›

ã¾ãšã¯ Free Generator ã‹ã‚‰ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã¸ã®å¤‰æ›ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚å®Ÿè£…ã™ã‚‹å‰ã«ä¾‹å¤–ã‚±ãƒ¼ã‚¹ã‚’å–ã‚Šæ‰±ã†ãŸã‚ã® Pattern Synonyms ã¨è£œåŠ©é–¢æ•°ã‚’ç”¨æ„ã—ã¦ãŠãã¾ã™ã€‚

```hs
void :: FGen a
void = Bind (Pick []) Pure

pattern Void :: FGen a
pattern Void <- Bind (Pick []) _

isVoid :: FGen a -> Bool
isVoid Void = True
isVoid _    = False
```

ã“ã‚Œã‚‰ã‚’ä½¿ã£ã¦ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã¸ã®å¤‰æ›ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚

```hs
toG :: FGen a -> IO a
toG Void = undefined
toG (Pure a) = pure a
toG (Bind (Pick xs) f) = do
  x <- frequency $ map (\(w, _, x) -> (w, x)) xs
  a <- toG x
  toG (f a)
```

ã“ã®ã‚ˆã†ã«ã—ã¦ä½œã£ãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¸ã®å¤‰æ›ã‚’å®Ÿéš›ã«å‹•ã‹ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
> toG (fgenExpr 3)
Add (Sub (Sub (C 5) (C 9)) (Mul (C 9) (C 8))) (Add (Add (C 9) (C 9)) (Add (C 9) (C 8)))
```

æœŸå¾…é€šã‚Šã®æŒ™å‹•ã«ãªã£ã¦ã„ã¾ã™ã­ã€‚

åŒæ§˜ã«ãƒ‘ãƒ¼ã‚µãƒ¼ã¸ã®å¤‰æ›ã‚‚å®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
toP :: FGen a -> ReadP a
toP Void = pfail
toP (Pure a) = pure a
toP (Bind (Pick xs) f) = do
  c <- get
  x <- case find (\(_, d, _) -> c == d) xs of
         Just (_, _, x) -> pure x
         Nothing -> pfail
  a <- toP x
  toP (f a)
```

ä½œã£ãŸãƒ‘ãƒ¼ã‚µãƒ¼ã¸ã®å¤‰æ›ã‚’å®Ÿéš›ã«å‹•ã‹ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
> readP_to_S (toP (fgenExpr 3)) "*+c1c4c3"
[(Mul (Add (C 1) (C 4)) (C 3),"")]
```

æœŸå¾…é€šã‚Šã«å‹•ã„ã¦ã„ã¾ã™ã­ã€‚

ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’ä½¿ã£ã¦ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‹ãŸã‚ã«ã¯æ§‹æ–‡è§£æã‚’è¡Œã†å¯¾è±¡ã€ã™ãªã‚ã¡ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã‚’ä½œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã‚‚ã“ã‚Œã¾ã§åŒæ§˜ Free Generator ã‚’å¤‰æ›ã™ã‚‹ã“ã¨ã§ä½œã‚Šã¾ã™ã€‚

```hs
toR :: FGen a -> IO String
toR Void = undefined
toR (Pure _) = pure ""
toR (Bind (Pick xs) f) = do
  (c, x) <- frequency (map (\(w, c, x) -> (w, (c, x))) xs)
  s <- toR (x >>= f)
  pure (c:s)
```

ã“ã®ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã‚’ `Expr` ã®å ´åˆã«å®Ÿè¡Œã™ã‚‹ã¨ã€ãƒ©ãƒ³ãƒ€ãƒ ãªæ•°å¼ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’åãå‡ºã™ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

```hs
> toR (fgenExpr 3)
"**-c7c8+c6c6c5"
```

ã“ã‚Œã¾ã§ã«å®Ÿè£…ã—ãŸ `toG`, `toP`, `toR` ã¯å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿å‹ `Expr` ã«ã¯ä¾å­˜ã›ãšã€ **æŠ½è±¡çš„ãª Free Generator `FGen a` ã‹ã‚‰ã®å¤‰æ›ã«ãªã£ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ãŒé‡è¦** ã§ã™ã€‚

æœ€å¾Œã«ãƒ‘ãƒ¼ã‚µãƒ¼ã¸ã®å¤‰æ› `toP` ã¨ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã¸ã®å¤‰æ› `toR` ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¸ã®å¤‰æ› `toG` ã‚’å†ç¾ã§ãã‚‹ã“ã¨ã‚’å®Ÿè£…ã—ã¦ç¢ºèªã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
toG' :: FGen a -> IO a
toG' g = (fst . head) <$> (readP_to_S (toP g) <$> toR g)
```

å‹ã®é•ã„ã‚’å¸åã™ã‚‹ãŸã‚ã«ã„ãã¤ã‹ä½™åˆ†ãªé–¢æ•°ã‚’é©ç”¨ã—ã¦ã„ã¾ã™ãŒã€æœ¬è³ªçš„ã«ã¯

```hs
toG g â‰… toP g <$> toR g
```

ã¨ã„ã†é–¢ä¿‚ã«ãªã£ã¦ã„ã‚‹ã®ãŒåˆ†ã‹ã‚‹ã¨æ€ã„ã¾ã™ã€‚

æœ€å¾Œã«å¿µã®ç‚ºã€ã“ã®ã‚ˆã†ã«å®Ÿè£…ã—ãŸ `toG'` ã‚’å®Ÿéš›ã«å®Ÿè¡Œã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```hs
> toG' (fgenExpr 3)
Mul (Mul (C 7) (Mul (C 0) (C 7))) (Add (Add (C 5) (C 2)) (Add (C 3) (C 7)))
```

æœŸå¾…é€šã‚Šãƒ©ãƒ³ãƒ€ãƒ ãªæ•°å¼ãŒç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ã­ğŸ‘

## ã¾ã¨ã‚
ã“ã®è¨˜äº‹ã§ã¯ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®å€¤ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ç”Ÿæˆã™ã‚‹ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã¨ãã®ãƒ‘ãƒ¼ã‚µãƒ¼ã®çµ„ã¿åˆã‚ã›ã§æ›¸ã‘ã‚‹ã¨ã„ã†ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚ã“ã®è¨˜äº‹ã§å®Ÿè£…ã—ãŸã‚³ãƒ¼ãƒ‰ã¯[ã“ã¡ã‚‰ã®Replit](https://replit.com/@lotz84/UtilizedLightblueKey#Main.hs)ã§å…¨ã¦å…¬é–‹ã—ã¦ã„ã‚‹ã®ã§ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§è©¦ã™ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚

ã“ã®è¨˜äº‹ã§å–ã‚Šä¸Šã’ãŸè©±ã«åŠ ãˆã€åŸè«–æ–‡ã§ã¯ã•ã‚‰ã« Free Generator ã®å¾®åˆ†ã‚’å®šç¾©ã—ã€ãã‚Œã‚’æ´»ç”¨ã—ãŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ‰‹æ³•ã§ã‚ã‚‹é¸æŠå‹¾é…ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆCGSï¼‰ã¨ã„ã†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã€æ—¢å­˜ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆæ£„å´ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰ã¨ã®æ¯”è¼ƒã‚‚è¡Œã£ã¦ã„ã¾ã™ã€‚æ°—ã«ãªã‚‹äººã¯åŸè«–æ–‡ã‚‚ãƒã‚§ãƒƒã‚¯ã—ã¦ã¿ã¦ãã ã•ã„ï¼

https://dl.acm.org/doi/10.1145/3563291

----

ï¼¼èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼ï¼

ã“ã®è¨˜äº‹ãŒé¢ç™½ã‹ã£ãŸã‚‰ ã„ã„ã­â™¡ ã‚’ã„ãŸã ã‘ã‚‹ã¨å¬‰ã—ã„ã§ã™â˜ºï¸
100å††ã‹ã‚‰ã§ã‚‚ ã‚µãƒãƒ¼ãƒˆÂ¥ ã‚’ã„ãŸã ã‘ã‚Œã°æ¬¡ã®è¨˜äº‹ã‚’æ›¸ããŸã‚åŠ±ã¿ã«ãªã‚Šã¾ã™ğŸ™Œ